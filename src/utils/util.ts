/**
 *
 * @param newVal indx that need to be check
 * @param totalVal total allow values
 * @returns value by capping it to the allow values
 */
export const capIndx = (newVal: number, totalVal: number): number => {
	if (newVal < 0) return 0;
	else if (newVal >= totalVal) return totalVal - 1;
	else return newVal;
};

/**
 *
 * @returns Return a random UUID string
 *
 * In non-secure context, a weak UUID will be return generated by Math.random()
 */
export const getUUID = (): string => {
	const charSet: string[] = Array.from({ length: 10 }, (_, i) => `${i}`).concat(
		Array.from({ length: 6 }, (_, i) =>
			String.fromCharCode(i + "a".charCodeAt(0)),
		),
	);
	if (window.crypto && window.crypto.randomUUID) {
		return window.crypto.randomUUID();
	} else {
		const UUIDPatrn = `${"x".repeat(8)}-${"x".repeat(4)}-${"x".repeat(
			4,
		)}-${"x".repeat(4)}-${"x".repeat(12)}`;
		return UUIDPatrn.split("")
			.map((d) =>
				d !== "-" ? charSet[Math.floor(Math.random() * charSet.length)] : "-",
			)
			.join("");
	}
};

export const isAccptImg = (type: string): boolean => {
	// TODO: check type follow pattern: image/*
	return /image\/.*/.test(type);
};

export const b64ToBlob = (
	blob: string,
	type: string,
	chunkSize: number = 512,
): Blob => {
	const byteCharacters = atob(blob);
	const byteArrays = [];

	for (let offset = 0; offset < byteCharacters.length; offset += chunkSize) {
		const slice = byteCharacters.slice(offset, offset + chunkSize);

		const byteNumbers = new Array(slice.length);
		for (let i = 0; i < slice.length; i++) {
			byteNumbers[i] = slice.charCodeAt(i);
		}

		const byteArray = new Uint8Array(byteNumbers);
		byteArrays.push(byteArray);
	}

	return new Blob(byteArrays, { type });
};

export const blobToFile = (
	blob: Blob,
	fileName: string,
	type: string,
	lastMod?: number,
): File => {
	return new File([blob], fileName, {
		type,
		lastModified: lastMod ?? Date.now(),
	});
};

/**
 *
 * @param size in bytes
 * @param precision no of trailing decimal place
 * @returns a string by converting the byte to readable size unit
 */
export const sizeHumanizer = (
	size: number,
	precision: number = 100,
): string => {
	const units = ["B", "KB", "MB", "GB", "TB", "PB"];

	let unitIndx = 0;
	while (size >= 2 ** 10 && unitIndx < units.length - 1) {
		unitIndx++;
		size /= 2 ** 10;
	}
	size = Math.floor(size * precision) / precision;
	return `${size} ${units[unitIndx]}`;
};
